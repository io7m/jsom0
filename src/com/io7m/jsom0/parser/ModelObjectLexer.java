/* The following code was generated by JFlex 1.4.3 on 29/01/12 20:37 */

package com.io7m.jsom0.parser;

import java.io.IOException;

public final class ModelObjectLexer
{

  /** This character denotes the end of file */
  private static final int    YYEOF                 = -1;

  /** initial size of the lookahead buffer */
  private static final int    ZZ_BUFFERSIZE         = 16384;

  /** lexical states */
  private static final int    STATE_STRING          = 2;
  private static final int    YYINITIAL             = 0;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l at the
   * beginning of a line l is of the form l = 2*k, k a non negative integer
   */
  private static final int    ZZ_LEXSTATE[]         = { 0, 0, 1, 1 };

  /**
   * Translates characters to character classes
   */
  private static final String ZZ_CMAP_PACKED        =
                                                      "\11\0\1\7\1\6\1\0\1\7\1\5\22\0\1\7\1\0\1\12"
                                                        + "\4\0\1\21\5\0\1\3\1\4\1\0\1\1\11\2\1\0\1\13"
                                                        + "\5\0\32\10\1\0\1\11\2\0\1\10\1\0\1\10\1\14\3\10"
                                                        + "\1\17\7\10\1\16\3\10\1\20\1\10\1\15\6\10\57\0\1\10"
                                                        + "\12\0\1\10\4\0\1\10\5\0\27\10\1\0\37\10\1\0\u013f\10"
                                                        + "\31\0\162\10\4\0\14\10\16\0\5\10\11\0\1\10\213\0\1\10"
                                                        + "\13\0\1\10\1\0\3\10\1\0\1\10\1\0\24\10\1\0\54\10"
                                                        + "\1\0\46\10\1\0\5\10\4\0\202\10\10\0\105\10\1\0\46\10"
                                                        + "\2\0\2\10\6\0\20\10\41\0\46\10\2\0\1\10\7\0\47\10"
                                                        + "\110\0\33\10\5\0\3\10\56\0\32\10\5\0\13\10\25\0\12\10"
                                                        + "\4\0\2\10\1\0\143\10\1\0\1\10\17\0\2\10\7\0\2\10"
                                                        + "\12\10\3\10\2\0\1\10\20\0\1\10\1\0\36\10\35\0\3\10"
                                                        + "\60\0\46\10\13\0\1\10\u0152\0\66\10\3\0\1\10\22\0\1\10"
                                                        + "\7\0\12\10\4\0\12\10\25\0\10\10\2\0\2\10\2\0\26\10"
                                                        + "\1\0\7\10\1\0\1\10\3\0\4\10\3\0\1\10\36\0\2\10"
                                                        + "\1\0\3\10\4\0\12\10\2\10\23\0\6\10\4\0\2\10\2\0"
                                                        + "\26\10\1\0\7\10\1\0\2\10\1\0\2\10\1\0\2\10\37\0"
                                                        + "\4\10\1\0\1\10\7\0\12\10\2\0\3\10\20\0\11\10\1\0"
                                                        + "\3\10\1\0\26\10\1\0\7\10\1\0\2\10\1\0\5\10\3\0"
                                                        + "\1\10\22\0\1\10\17\0\2\10\4\0\12\10\25\0\10\10\2\0"
                                                        + "\2\10\2\0\26\10\1\0\7\10\1\0\2\10\1\0\5\10\3\0"
                                                        + "\1\10\36\0\2\10\1\0\3\10\4\0\12\10\1\0\1\10\21\0"
                                                        + "\1\10\1\0\6\10\3\0\3\10\1\0\4\10\3\0\2\10\1\0"
                                                        + "\1\10\1\0\2\10\3\0\2\10\3\0\3\10\3\0\10\10\1\0"
                                                        + "\3\10\55\0\11\10\25\0\10\10\1\0\3\10\1\0\27\10\1\0"
                                                        + "\12\10\1\0\5\10\46\0\2\10\4\0\12\10\25\0\10\10\1\0"
                                                        + "\3\10\1\0\27\10\1\0\12\10\1\0\5\10\3\0\1\10\40\0"
                                                        + "\1\10\1\0\2\10\4\0\12\10\25\0\10\10\1\0\3\10\1\0"
                                                        + "\27\10\1\0\20\10\46\0\2\10\4\0\12\10\25\0\22\10\3\0"
                                                        + "\30\10\1\0\11\10\1\0\1\10\2\0\7\10\72\0\60\10\1\0"
                                                        + "\2\10\14\0\7\10\11\0\12\10\47\0\2\10\1\0\1\10\2\0"
                                                        + "\2\10\1\0\1\10\2\0\1\10\6\0\4\10\1\0\7\10\1\0"
                                                        + "\3\10\1\0\1\10\1\0\1\10\2\0\2\10\1\0\4\10\1\0"
                                                        + "\2\10\11\0\1\10\2\0\5\10\1\0\1\10\11\0\12\10\2\0"
                                                        + "\2\10\42\0\1\10\37\0\12\10\26\0\10\10\1\0\42\10\35\0"
                                                        + "\4\10\164\0\42\10\1\0\5\10\1\0\2\10\25\0\12\10\6\0"
                                                        + "\6\10\112\0\46\10\12\0\51\10\7\0\132\10\5\0\104\10\5\0"
                                                        + "\122\10\6\0\7\10\1\0\77\10\1\0\1\10\1\0\4\10\2\0"
                                                        + "\7\10\1\0\1\10\1\0\4\10\2\0\47\10\1\0\1\10\1\0"
                                                        + "\4\10\2\0\37\10\1\0\1\10\1\0\4\10\2\0\7\10\1\0"
                                                        + "\1\10\1\0\4\10\2\0\7\10\1\0\7\10\1\0\27\10\1\0"
                                                        + "\37\10\1\0\1\10\1\0\4\10\2\0\7\10\1\0\47\10\1\0"
                                                        + "\23\10\16\0\11\10\56\0\125\10\14\0\u026c\10\2\0\10\10\12\0"
                                                        + "\32\10\5\0\113\10\25\0\15\10\1\0\4\10\16\0\22\10\16\0"
                                                        + "\22\10\16\0\15\10\1\0\3\10\17\0\64\10\43\0\1\10\4\0"
                                                        + "\1\10\3\0\12\10\46\0\12\10\6\0\130\10\10\0\51\10\127\0"
                                                        + "\35\10\51\0\12\10\36\10\2\0\5\10\u038b\0\154\10\224\0\234\10"
                                                        + "\4\0\132\10\6\0\26\10\2\0\6\10\2\0\46\10\2\0\6\10"
                                                        + "\2\0\10\10\1\0\1\10\1\0\1\10\1\0\1\10\1\0\37\10"
                                                        + "\2\0\65\10\1\0\7\10\1\0\1\10\3\0\3\10\1\0\7\10"
                                                        + "\3\0\4\10\2\0\6\10\4\0\15\10\5\0\3\10\1\0\7\10"
                                                        + "\164\0\1\10\15\0\1\10\202\0\1\10\4\0\1\10\2\0\12\10"
                                                        + "\1\0\1\10\3\0\5\10\6\0\1\10\1\0\1\10\1\0\1\10"
                                                        + "\1\0\4\10\1\0\3\10\1\0\7\10\3\0\3\10\5\0\5\10"
                                                        + "\u0ebb\0\2\10\52\0\5\10\5\0\2\10\4\0\126\10\6\0\3\10"
                                                        + "\1\0\132\10\1\0\4\10\5\0\50\10\4\0\136\10\21\0\30\10"
                                                        + "\70\0\20\10\u0200\0\u19b6\10\112\0\u51a6\10\132\0\u048d\10\u0773\0\u2ba4\10"
                                                        + "\u215c\0\u012e\10\2\0\73\10\225\0\7\10\14\0\5\10\5\0\1\10"
                                                        + "\1\0\12\10\1\0\15\10\1\0\5\10\1\0\1\10\1\0\2\10"
                                                        + "\1\0\2\10\1\0\154\10\41\0\u016b\10\22\0\100\10\2\0\66\10"
                                                        + "\50\0\14\10\164\0\5\10\1\0\207\10\23\0\12\10\7\0\32\10"
                                                        + "\6\0\32\10\13\0\131\10\3\0\6\10\2\0\6\10\2\0\6\10"
                                                        + "\2\0\3\10\43\0";

  /**
   * Translates characters to character classes
   */
  private static final char[] ZZ_CMAP               =
                                                      ModelObjectLexer
                                                        .zzUnpackCMap(ModelObjectLexer.ZZ_CMAP_PACKED);

  /**
   * Translates DFA states to action switch labels.
   */
  private static final int[]  ZZ_ACTION             = ModelObjectLexer
                                                      .zzUnpackAction();

  private static final String ZZ_ACTION_PACKED_0    =
                                                      "\2\0\1\1\2\2\2\3\2\4\1\5\1\6\1\7"
                                                        + "\2\10\1\1\1\11\4\3\1\12\1\13\1\14\1\15"
                                                        + "\1\16\1\17\1\20\1\21\1\22\1\23\1\0";

  /**
   * Translates a state to a row index in the transition table
   */
  private static final int[]  ZZ_ROWMAP             = ModelObjectLexer
                                                      .zzUnpackRowMap();

  private static final String ZZ_ROWMAP_PACKED_0    =
                                                      "\0\0\0\22\0\44\0\66\0\110\0\132\0\154\0\176"
                                                        + "\0\44\0\44\0\44\0\220\0\242\0\44\0\264\0\44"
                                                        + "\0\306\0\66\0\330\0\352\0\44\0\44\0\44\0\44"
                                                        + "\0\44\0\44\0\44\0\44\0\44\0\306\0\374";

  /**
   * The transition table of the DFA
   */
  private static final int[]  ZZ_TRANS              = ModelObjectLexer
                                                      .zzUnpackTrans();

  private static final String ZZ_TRANS_PACKED_0     =
                                                      "\1\3\1\4\1\5\1\6\1\7\1\10\2\11\1\7"
                                                        + "\1\3\1\12\1\13\5\7\1\3\5\14\1\15\1\16"
                                                        + "\2\14\1\17\1\20\7\14\23\0\3\7\1\21\3\0"
                                                        + "\1\7\3\0\5\7\2\0\2\5\1\7\1\21\3\0"
                                                        + "\1\7\3\0\5\7\2\0\1\22\1\23\1\24\1\7"
                                                        + "\3\0\1\7\3\0\5\7\2\0\4\7\3\0\1\7"
                                                        + "\3\0\5\7\7\0\1\11\13\0\5\14\2\0\2\14"
                                                        + "\2\0\7\14\6\0\1\16\13\0\6\25\1\0\2\25"
                                                        + "\1\26\1\27\1\25\1\30\1\31\1\32\1\33\1\34"
                                                        + "\1\35\1\0\2\36\2\7\3\0\1\7\3\0\5\7"
                                                        + "\2\0\2\23\1\7\1\21\3\0\1\7\3\0\5\7"
                                                        + "\1\0\1\37\4\24\1\10\1\11\1\37\1\24\3\37"
                                                        + "\5\24\6\37\1\10\1\11\13\37";

  /* error codes */
  private static final int    ZZ_UNKNOWN_ERROR      = 0;

  private static final int    ZZ_NO_MATCH           = 1;

  /* error messages for the codes above */
  private static final String ZZ_ERROR_MSG[]        = {
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"          };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private static final int[]  ZZ_ATTRIBUTE          = ModelObjectLexer
                                                      .zzUnpackAttribute();

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
                                                      "\2\0\1\11\5\1\3\11\2\1\1\11\1\1\1\11"
                                                        + "\4\1\11\11\1\1\1\0";

  /**
   * Reports an error that occured while scanning.
   * 
   * In a wellformed scanner (no or only correct usage of yypushback(int) and
   * a match-all fallback rule) this method will only be called with things
   * that "Can't Possibly Happen". If this method is called, something is
   * seriously wrong (e.g. a JFlex bug producing a faulty scanner etc.).
   * 
   * Usual syntax/scanner level error handling should be done in error
   * fallback rules.
   * 
   * @param errorCode
   *          the code of the errormessage to display
   * @throws Error
   */
  private static void zzScanError(
    final int errorCode)
    throws Error
  {
    String message;
    try {
      message = ModelObjectLexer.ZZ_ERROR_MSG[errorCode];
    } catch (final ArrayIndexOutOfBoundsException e) {
      message =
        ModelObjectLexer.ZZ_ERROR_MSG[ModelObjectLexer.ZZ_UNKNOWN_ERROR];
    }

    throw Error.lexicalError(message);
  }

  private static int[] zzUnpackAction()
  {
    final int[] result = new int[31];
    int offset = 0;
    offset =
      ModelObjectLexer.zzUnpackAction(
        ModelObjectLexer.ZZ_ACTION_PACKED_0,
        offset,
        result);
    return result;
  }

  private static int zzUnpackAction(
    final String packed,
    final int offset,
    final int[] result)
  {
    int i = 0; /* index in packed string */
    int j = offset; /* index in unpacked array */
    final int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      final int value = packed.charAt(i++);
      do {
        result[j++] = value;
      } while (--count > 0);
    }
    return j;
  }

  private static int[] zzUnpackAttribute()
  {
    final int[] result = new int[31];
    int offset = 0;
    offset =
      ModelObjectLexer.zzUnpackAttribute(
        ModelObjectLexer.ZZ_ATTRIBUTE_PACKED_0,
        offset,
        result);
    return result;
  }

  private static int zzUnpackAttribute(
    final String packed,
    final int offset,
    final int[] result)
  {
    int i = 0; /* index in packed string */
    int j = offset; /* index in unpacked array */
    final int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      final int value = packed.charAt(i++);
      do {
        result[j++] = value;
      } while (--count > 0);
    }
    return j;
  }

  /**
   * Unpacks the compressed character translation table.
   * 
   * @param packed
   *          the packed character translation table
   * @return the unpacked character translation table
   */
  private static char[] zzUnpackCMap(
    final String packed)
  {
    final char[] map = new char[0x10000];
    int i = 0; /* index in packed string */
    int j = 0; /* index in unpacked array */
    while (i < 1246) {
      int count = packed.charAt(i++);
      final char value = packed.charAt(i++);
      do {
        map[j++] = value;
      } while (--count > 0);
    }
    return map;
  }

  private static int[] zzUnpackRowMap()
  {
    final int[] result = new int[31];
    int offset = 0;
    offset =
      ModelObjectLexer.zzUnpackRowMap(
        ModelObjectLexer.ZZ_ROWMAP_PACKED_0,
        offset,
        result);
    return result;
  }

  private static int zzUnpackRowMap(
    final String packed,
    final int offset,
    final int[] result)
  {
    int i = 0; /* index in packed string */
    int j = offset; /* index in unpacked array */
    final int l = packed.length();
    while (i < l) {
      final int high = packed.charAt(i++) << 16;
      result[j++] = high | packed.charAt(i++);
    }
    return j;
  }

  private static int[] zzUnpackTrans()
  {
    final int[] result = new int[270];
    int offset = 0;
    offset =
      ModelObjectLexer.zzUnpackTrans(
        ModelObjectLexer.ZZ_TRANS_PACKED_0,
        offset,
        result);
    return result;
  }

  private static int zzUnpackTrans(
    final String packed,
    final int offset,
    final int[] result)
  {
    int i = 0; /* index in packed string */
    int j = offset; /* index in unpacked array */
    final int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do {
        result[j++] = value;
      } while (--count > 0);
    }
    return j;
  }

  /** the input device */
  private final java.io.Reader zzReader;

  /** the current state of the DFA */
  private int                  zzState;

  /** the current lexical state */
  private int                  zzLexicalState = ModelObjectLexer.YYINITIAL;

  /**
   * this buffer contains the current text to be matched and is the source of
   * the yytext() string
   */
  private char                 zzBuffer[]     =
                                                new char[ModelObjectLexer.ZZ_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int                  zzMarkedPos;

  /** the current text position in the buffer */
  private int                  zzCurrentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int                  zzStartRead;

  /**
   * endRead marks the last character in the buffer, that has been read from
   * input
   */
  private int                  zzEndRead;

  /** number of newlines encountered up to the start of the matched text */
  private int                  yyline;

  /**
   * the number of characters from the last newline up to the start of the
   * matched text
   */
  private int                  yycolumn;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private boolean              zzAtEOF;

  /* user code: */
  private final StringBuilder  buffer         = new StringBuilder();

  /**
   * Creates a new scanner. There is also java.io.Reader version of this
   * constructor.
   * 
   * @param in
   *          the java.io.Inputstream to read input from.
   */
  public ModelObjectLexer(
    final java.io.InputStream in)
  {
    this(new java.io.InputStreamReader(in));
  }

  /**
   * Creates a new scanner There is also a java.io.InputStream version of this
   * constructor.
   * 
   * @param in
   *          the java.io.Reader to read input from.
   */
  ModelObjectLexer(
    final java.io.Reader in)
  {
    this.zzReader = in;
  }

  public ModelObjectToken token()
    throws IOException,
      Error
  {
    return this.yylex();
  }

  /**
   * Enters a new lexical state
   * 
   * @param newState
   *          the new lexical state
   */
  private final void yybegin(
    final int newState)
  {
    this.zzLexicalState = newState;
  }

  /**
   * Resumes scanning until the next regular expression is matched, the end of
   * input is encountered or an I/O-Error occurs.
   * 
   * @return the next token
   * @exception java.io.IOException
   *              if any I/O-Error occurs
   * @throws Error
   */
  private ModelObjectToken yylex()
    throws java.io.IOException,
      Error
  {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = this.zzEndRead;
    char[] zzBufferL = this.zzBuffer;
    final char[] zzCMapL = ModelObjectLexer.ZZ_CMAP;

    final int[] zzTransL = ModelObjectLexer.ZZ_TRANS;
    final int[] zzRowMapL = ModelObjectLexer.ZZ_ROWMAP;
    final int[] zzAttrL = ModelObjectLexer.ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = this.zzMarkedPos;

      boolean zzR = false;
      for (zzCurrentPosL = this.zzStartRead; zzCurrentPosL < zzMarkedPosL; zzCurrentPosL++) {
        switch (zzBufferL[zzCurrentPosL]) {
          case '\u000B':
          case '\u000C':
          case '\u0085':
          case '\u2028':
          case '\u2029':
            this.yyline++;
            this.yycolumn = 0;
            zzR = false;
            break;
          case '\r':
            this.yyline++;
            this.yycolumn = 0;
            zzR = true;
            break;
          case '\n':
            if (zzR) {
              zzR = false;
            } else {
              this.yyline++;
              this.yycolumn = 0;
            }
            break;
          default:
            zzR = false;
            this.yycolumn++;
        }
      }

      if (zzR) {
        // peek one character ahead if it is \n (if we have counted one line
        // too much)
        boolean zzPeek;
        if (zzMarkedPosL < zzEndReadL) {
          zzPeek = zzBufferL[zzMarkedPosL] == '\n';
        } else if (this.zzAtEOF) {
          zzPeek = false;
        } else {
          final boolean eof = this.zzRefill();
          zzEndReadL = this.zzEndRead;
          zzMarkedPosL = this.zzMarkedPos;
          zzBufferL = this.zzBuffer;
          if (eof) {
            zzPeek = false;
          } else {
            zzPeek = zzBufferL[zzMarkedPosL] == '\n';
          }
        }
        if (zzPeek) {
          this.yyline--;
        }
      }
      zzAction = -1;

      zzCurrentPosL = this.zzCurrentPos = this.zzStartRead = zzMarkedPosL;

      this.zzState = ModelObjectLexer.ZZ_LEXSTATE[this.zzLexicalState];

      zzForAction:
      {
        while (true) {

          if (zzCurrentPosL < zzEndReadL) {
            zzInput = zzBufferL[zzCurrentPosL++];
          } else if (this.zzAtEOF) {
            zzInput = ModelObjectLexer.YYEOF;
            break zzForAction;
          } else {
            // store back cached positions
            this.zzCurrentPos = zzCurrentPosL;
            this.zzMarkedPos = zzMarkedPosL;
            final boolean eof = this.zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL = this.zzCurrentPos;
            zzMarkedPosL = this.zzMarkedPos;
            zzBufferL = this.zzBuffer;
            zzEndReadL = this.zzEndRead;
            if (eof) {
              zzInput = ModelObjectLexer.YYEOF;
              break zzForAction;
            }
            zzInput = zzBufferL[zzCurrentPosL++];
          }
          final int zzNext =
            zzTransL[zzRowMapL[this.zzState] + zzCMapL[zzInput]];
          if (zzNext == -1) {
            break zzForAction;
          }
          this.zzState = zzNext;

          final int zzAttributes = zzAttrL[this.zzState];
          if ((zzAttributes & 1) == 1) {
            zzAction = this.zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ((zzAttributes & 8) == 8) {
              break zzForAction;
            }
          }

        }
      }

      // store back cached position
      this.zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ModelObjectLexer.ZZ_ACTION[zzAction]) {
        case 3:
        {
          return new ModelObjectToken(
            ModelObjectTokenType.OBJECT_TOKEN_SYMBOL,
            this.yytext(),
            new Position(this.yyline, this.yycolumn));
        }
        case 20:
          break;
        case 18:
        {
          this.buffer.append('\'');
        }
        //$FALL-THROUGH$
        case 21:
          break;
        case 4:
        { /* Ignore */
        }
        //$FALL-THROUGH$
        case 22:
          break;
        case 7:
        {
          this.buffer.append(this.yytext());
        }
        //$FALL-THROUGH$
        case 23:
          break;
        case 10:
        {
          throw Error.lexicalError("Illegal escape sequence \""
            + this.yytext()
            + "\"");
        }
        case 24:
          break;
        case 2:
        {
          return new ModelObjectToken(
            ModelObjectTokenType.OBJECT_TOKEN_LITERAL_DECIMAL,
            this.yytext(),
            new Position(this.yyline, this.yycolumn));
        }
        case 25:
          break;
        case 17:
        {
          this.buffer.append('\r');
        }
        //$FALL-THROUGH$
        case 26:
          break;
        case 9:
        {
          this.yybegin(ModelObjectLexer.YYINITIAL);
          return new ModelObjectToken(
            ModelObjectTokenType.OBJECT_TOKEN_LITERAL_STRING,
            this.buffer.toString(),
            new Position(this.yyline, this.yycolumn));
        }
        case 27:
          break;
        case 19:
        {
          return new ModelObjectToken(
            ModelObjectTokenType.OBJECT_TOKEN_LITERAL_FLOAT,
            this.yytext(),
            new Position(this.yyline, this.yycolumn));
        }
        case 28:
          break;
        case 13:
        {
          this.buffer.append('\b');
        }
        //$FALL-THROUGH$
        case 29:
          break;
        case 14:
        {
          this.buffer.append('\t');
        }
        //$FALL-THROUGH$
        case 30:
          break;
        case 8:
        {
          throw Error.lexicalError("Unterminated string at end of line");
        }
        case 31:
          break;
        case 6:
        {
          return new ModelObjectToken(
            ModelObjectTokenType.OBJECT_TOKEN_SEMICOLON,
            this.yytext(),
            new Position(this.yyline, this.yycolumn));
        }
        case 32:
          break;
        case 11:
        {
          this.buffer.append('\\');
        }
        //$FALL-THROUGH$
        case 33:
          break;
        case 15:
        {
          this.buffer.append('\n');
        }
        //$FALL-THROUGH$
        case 34:
          break;
        case 16:
        {
          this.buffer.append('\f');
        }
        //$FALL-THROUGH$
        case 35:
          break;
        case 1:
        {
          throw Error.lexicalError("Illegal character <"
            + this.yytext()
            + ">");
        }
        case 36:
          break;
        case 12:
        {
          this.buffer.append('\"');
        }
        //$FALL-THROUGH$
        case 37:
          break;
        case 5:
        {
          this.yybegin(ModelObjectLexer.STATE_STRING);
          this.buffer.setLength(0);
        }
        //$FALL-THROUGH$
        case 38:
          break;
        default:
          if ((zzInput == ModelObjectLexer.YYEOF)
            && (this.zzStartRead == this.zzCurrentPos)) {
            this.zzAtEOF = true;
            {
              return new ModelObjectToken(
                ModelObjectTokenType.OBJECT_TOKEN_EOF,
                "",
                new Position(this.yyline, this.yycolumn));
            }
          }
          ModelObjectLexer.zzScanError(ModelObjectLexer.ZZ_NO_MATCH);
      }
    }
  }

  /**
   * Returns the text matched by the current regular expression.
   */
  private final String yytext()
  {
    return new String(this.zzBuffer, this.zzStartRead, this.zzMarkedPos
      - this.zzStartRead);
  }

  /**
   * Refills the input buffer.
   * 
   * @return <code>false</code>, iff there was new input.
   * 
   * @exception java.io.IOException
   *              if any I/O-Error occurs
   */
  private boolean zzRefill()
    throws java.io.IOException
  {

    /* first: make room (if you can) */
    if (this.zzStartRead > 0) {
      System.arraycopy(
        this.zzBuffer,
        this.zzStartRead,
        this.zzBuffer,
        0,
        this.zzEndRead - this.zzStartRead);

      /* translate stored positions */
      this.zzEndRead -= this.zzStartRead;
      this.zzCurrentPos -= this.zzStartRead;
      this.zzMarkedPos -= this.zzStartRead;
      this.zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (this.zzCurrentPos >= this.zzBuffer.length) {
      /* if not: blow it up */
      final char newBuffer[] = new char[this.zzCurrentPos * 2];
      System.arraycopy(this.zzBuffer, 0, newBuffer, 0, this.zzBuffer.length);
      this.zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    final int numRead =
      this.zzReader.read(this.zzBuffer, this.zzEndRead, this.zzBuffer.length
        - this.zzEndRead);

    if (numRead > 0) {
      this.zzEndRead += numRead;
      return false;
    }
    // unlikely but not impossible: read 0 characters, but not at end of
    // stream
    if (numRead == 0) {
      final int c = this.zzReader.read();
      if (c == -1) {
        return true;
      }
      this.zzBuffer[this.zzEndRead++] = (char) c;
      return false;
    }

    // numRead < 0
    return true;
  }

}
